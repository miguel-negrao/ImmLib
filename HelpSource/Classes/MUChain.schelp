TITLE:: MUChain
summary:: A class for running multiple UChains in parallel
categories::ImmLib
related:: Classes/UChain, Classes/MU

DESCRIPTION::
This class behaves virtually identically to UChain (unit), but in the background it will play multiple copies of the same unit at the same time.

It is implemented using ClusterBasic for runtime redirection of the methods to each of the parallel uchains.


CLASSMETHODS::

METHOD:: new
The new method requires at least on the arguments to be or have embeded somewhere inside an array a ClusterArg instance. The ClusterArg instance determines how many parallel units to create.

When using modulators with the units they should be of the kind MUEvNetTModDef or MUENTModDef.

METHOD:: immNew
ImmDef library:
this method is the same as UChain:new but the first argument is a PSurface which is used to evaluate all PFields used with this UChain.

When using an MUChain via immNew it must always be placed inside an UScore.immNew, in order to create the panners.

ARGUMENT:: surface
PSurface

ARGUMENT::  ... args
The arguments of UChain:new

returns:: MUChain

EXAMPLES::

code::
(
q = ();

q.m = 20;

q.surface = PSurface.sphere(q.m);

q[\f] = { |t|

	var pf = PField({ |u, v, t|
		sin( 2pi * ( (0.3 * u) + (t*0.5)) )
	});

	var amp = pf.(t);

	PGridPlot( amp, "amp" );

	( \amp: USpecArg( amp ) )
};

q.chain1 = MUChain.immNew(q.surface, [\whiteNoise, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);

q.score = UScore.immNew(q.surface, q.chain1);
q.score.gui;
q.score.prepareAndStart;
)
::