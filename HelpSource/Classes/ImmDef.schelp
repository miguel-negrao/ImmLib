TITLE:: ImmDef
summary:: Definition of an event network for animating PFields
categories:: ImmLib
related:: Classes/PField

DESCRIPTION::
ImmDef stores a definition on an event network for animating PFields. The event network connects PFields and other sources of signals (MIDI, GUIs, OSC, etc) to parameters of MUChains.

PRIVATE::currentSurface, createDesc, unit, tESM

CLASSMETHODS::

METHOD:: new
(describe method here)

ARGUMENT:: descFunc
the function which creates the event network description. It should look like:


code::
f = { | timeSignal |

...

	(\key1: signal1, ... )
}
::

ARGUMENT:: surface
link::Classes/PSurface::

ARGUMENT:: delta
link::SimpleNumber:: - the animation delta time. The units and plots are updated every delta seconds.

returns:: Dictionary[ Symbol, link::Classes/FPSignal::[link::Classes/UModArg::[Array[Float]]] ]

discussion::
The dictionary returned will be used to connect each signal to the control with the corresponding key of an Udef. The signals should be wrapped in either a UArg which will use the values of the signal directly or USpecArg, in which case it will expect values in the [0,1] range and map them to the spec of that control.

INSTANCEMETHODS::

METHOD:: test
Allows testing PFields without actually connecting them to units. This makes it easy to test PFields by plotting them.

ARGUMENT:: startTime
Initial value of the time signal.

returns:: ImmDef


EXAMPLES::
A minimal example of one pfield controlling the amplitude of one unit.

code::
(
q = ();

q.m = 20;

q.surface = PSurface.sphere(q.m);

q[\f] = { |t|

	var pf = PField({ |u, v, t|
		sin( 2pi * ( (0.3 * u) + (t*0.5)) )
	});

	var amp = pf.(t);

	PGridPlot( amp, "amp" );

	( \amp: USpecArg( amp ) )
};

q.chain1 = MUChain.immNew(q.surface, [\whiteNoise, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);

q.score = UScore.immNew(q.surface, q.chain1);
q.score.gui;
q.score.prepareAndStart;
)
::