TITLE:: PField
summary:: A parameter field definition
categories:: ImmLib


DESCRIPTION::
Encapsulates a function RxRxRxR^n -> [0,1] where R are the real numbers

These are functions that will lool like

code::
f = { |u, v, t, c1, c2| ... }
::

Where u and v are two spatial coordinates, t is time and c1, c2, ... are parameters of the function.

PFields, like functions, can be evaluated using the value method or the syntax sugar code:: pfield.(t, param1, ...)::.

There are number of predefined PFields, that can be accessed through class methods. It's important to distinguish between two types of predefined PFields: pure pfields and pre-evaluated pfields. class methods for pure pfields (gradient, spotlight, spotlightFixed, barU, barV, sphericalHarmonic) return an instance of class PField, which can be evaluated using the code::value:: method. Also, they can be rotated using the code::rotate:: method and also they can be plotted using code::PSmoothPlot::. class methods for pre-evaluated pfields (wave2DSin, randomHills, etc) return an FPSignal, so there is no need for further evaluation. It's also not possible to rotate them, or use PSmoothPlot on them. Pre-evaluated pfields correspong to pfields which are not defined by pure mathematical functions, but instead besides pure mathematical functiosn they also use elements of functional reactive programming to make more complex behaviours, such as changing the mathematical function being used every n seconds, changing the rate of passage of time internally in order to make is possible to smoothly change the frequency of periodic function.

note:: The range of u and v will depend on the surface. This can be checked using link::Classes/PSurface#rangeU:: and link::Classes/PSurface#rangeV::. For a spherical surface the ranges are [0,2pi]x[-pi/2, pi/2] ::

note::For the plotting to work correctly the PField should output on the [0, 1] range.::

note::
It's important to distinguish the arguments to the creation methods of predefined PFields with the actual arguments of the function that PField encapsulates. Creation arguments are static, once set can't be changed, evaluation arguments can be modulated.
code::
x = PField.spotlightFixed(0, 0) //creation arguments
x.value(t, 0.5) //evaluation arguments
::
::

note::
Reading pseudo type signatures: The arguments and return values of the PField methods are anotated with pseudo type signatures.  ClassA[ ClassB, ClassC ] represents an objects of ClassA which contains or depends on objects of ClassB and Class C. So FPSignal[ Float ] represents an object of class FPSignal which carries floats. [A] is an array carrying values of type A (for homogenous arrays).
::

CLASSMETHODS::

PRIVATE::prBump, barFuncU, barFuncV, expandContract2Func, expandContractFunc, generateHillsBipolarFunc, gradientFunc, prGeodesicDist, prGeodesicDist2, randomPatchGeneral, spotlightFixedFunc, spotlightFunc, generateHillsFunc, continousRandomSpotlight3, gradientFFunc, selfSwitchPeriodically, waveUSin, waveVSin, animate

METHOD:: new
Creates a PField

ARGUMENT:: f
A function of type

code::
f = { |u, v, t, c1, c2| ... }
::

returns:: PField

discussion::

A PField can be any mathematical function that can be described by SuperCollider's language operators. It should return a number.

code::
(
ImmDef({ |t|

	var pf = PField({ |u, v, t|

		sin( 2pi * ( (0.3 * u) + t) )

	});

	pf.plot( t )

}).test
)

(
ImmDef({ |t|

	var pf = PField({ |u, v, t|

		sin( 2pi * ( (0.2 * u) + t) ) * sin( 2pi * ( (0.3 * v) + t ) + pi )

	});

	pf.plot( t )

}).test
)
(
q = ();
q.m = 40;
q.surface = PSphere(q.m);

q[\f] = { |t|
	var pf = PField({ |u, v, t|

		sin( 2pi * ( (0.2 * u) + t) ) * sin( 2pi * ( (0.3 * v) + t ) + pi )

	});

	var out = pf.plot( t );
	//no plotting
	//var out = pf.( t );

	(freq: UArg( out.linexp(0.0,1.0,100,10000) ))
};

q.chain = ImmUChain(q.surface, \immWhiteNoise, [\lowPass, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);
q.score = ImmUScore(q.surface, q.chain);
q.score.gui;
q.score.prepareAndStart
)
::

PFields are evaluated inside an event network. They are evaluated using the code::value:: method just like funtions. They should be passed in an FPSignal that carries the time events together with any other signals that controls the PField's parameters.














subsection:: Predefined PFields






METHOD:: gradient

A PField with value which goes from value a at point (u2,v2) to value b at points at the maximum distance from (u2,v2) with shape given by curve (curve = 1 is linear). The result at points in between is given by Env([0,1],[1],curve).at( dist(p,p2).linlin(0,maxDist,0,1) ).

The PField has arguments t, u2, v2, a, b, curve

returns:: PField

discussion::

code::
(
ImmDef({ |t|

	var pf = PField.gradient;
	//       t  u2   v2   a    b
	pf.plot( t, 0.0, 0.0, 0.0, 1.0 );

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)


(
ImmDef({ |t|

	var pf = PField.gradient;
	             //  t  u2   v2   a                              b
	pf.plot( t, 0.0, 0.0, { |x| (sin(x*2)+1)/2 } <%> t, { |x| (sin(x*3)+1)/2 } <%> t );
}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)
:
//sphere
(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, u2, v2, a, b, curve|

	var pf1 = PField.gradient.plot( t, u2, v2, a, b, curve );

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1,
[
	\u0, \azimuth,
	\v0, \elevation,
	\a, [0,1.0],
	\b,	[0,1.0],
	\curve,	ControlSpec(-6,6,default:0)
]);

q.mod = ImmMod(q.def, [\a, 0, \b, 1, \curve, 0]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)

//plane
(
ImmDef({ |t|

	var pf = PField.gradient;
	           //t  u2   v2   a                             b
	var x = pf.( t, 0.0, 0.0, { |x| (sin(x*2)+1)/2 } <%> t, { |x| (sin(x*3)+1)/2 } <%> t );
	x.enDebug("x");
	PGridPlot( x, "hello !")
}, surface: PPlane(RealVector3D[-1.0,-1.0,1.0], RealVector3D[2.0,0.0,0.0], RealVector3D[0.0,2.0,0.0] ), delta: 0.1).test( startTime:0.0)
)
::

METHOD:: gradientF

A PField with value which goes from value a at point p2 = (u2,v2) to value b at points at the maximum distance from (u2,v2) using a function f. The result at points in between is given by f( dist(p,p2)/maxDist) ).linlin(0,1,a,b)

The PField has arguments t, u2, v2, a, b

ARGUMENT:: f
A function f:[0,1] -> [0,1] used to interpolate from a to b. The final value is f(dist(p0,p1)).linlin(0,1,a,b)

returns:: PField

discussion::

code::
(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, u2, v2, a, b|

	//make our own non linear shape to go from a to b
	var x = Env([ 0.0, 1.0, 0.5, 1.0, 0.0 ], [ 0.25, 0.25, 0.25, 0.25 ], [ -2.2, 2.1, 1.8, -2 ]).asMultichannelArray[0];

	var f = { |c| x.envAt(c) };

	var pf1 = PSmoothPlot( PField.gradientF(f), t, u2, v2, a, b );

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1,
[
	\u0, \azimuth,
	\v0, \elevation,
	\a, [0,1.0],
	\b,	[0,1.0]
]);

q.mod = ImmMod(q.def, [\a, 0, \b, 1]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)
::

METHOD:: spotlight
A PField that grows symetrically from a start point until occupying all the surface.

The PField has arguments t, u2, v2, c, d=0.2 and returns 1 if the distanceof (u1,v1) to (u2,v2) is smaller then c and 0 otherwise. d controls how wide is the smoothing area between the transition area from 0 to 1.

returns:: PField

discussion::


code::
(
ImmDef({ |t|

	var pf = PField.spotlight;

	       //t, u,     v,    c,            d
	pf.plot( t, 0.0,   0.0,  t.lfsine(0.5),  0.0 );

}).test
)
::

code::
(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, u0, v0, c, d|

	var pf1 = PField.spotlight.plot( t, u0, v0, c, d );

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1,[
	\u0, \azimuth,
	\v0, \elevation,
	\c, [0,1.0],
	\d, [0,1.0]
]);

q.mod = ImmMod(q.def, [\c, 0.5]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)
::


On a plane:
code::
(
q = ();
q.surface = PPlane(RealVector3D[-1.0,-1.0,1.0], RealVector3D[2.0,0.0,0.0], RealVector3D[0.0,2.0,0.0] );

q.def = ImmDef({ |t, u0, v0, c, d|

	var x = PField.spotlight.( t, u0, v0, c, d );

	PGridPlot( x, "Spotlight on Plane");

	( amp: USpecArg( x ) )

}, q.surface, 0.1,[
	\u0, [0,1],
	\v0, [0,1],
	\c, [0,1.0],
	\d, [0,1.0]
]);

q.mod = ImmMod(q.def, [\c, 0.5]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)
::


METHOD:: spotlightFixed
like spotlight but the position of the point to which distance is being measured (u,v) is fixed and not modulatable. The PField function has arguments t, c (0-1), d (0-1).


ARGUMENT:: u
SimpleNumber - in range surface.manifold.rangeU

ARGUMENT:: v
SimpleNumber - in range surface.manifold.rangeV

returns:: PField

discussion::

code::
(
ImmDef({ |t|

	var pf = PField.spotlightFixed( pi/4, pi/2);
	               //time,  c
	PSmoothPlot( pf, t,     { |x| (sin(x*5)+1)/2 }.lift.(t) );

}).test
)

(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, c, d|

	var pf1 = PField.spotlightFixed(0.0,pi/2).plot( t, c, d );

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1,[
	\c, [0,1.0],
	\d, [0,1.0]
]);

q.mod = ImmMod(q.def, [\c, 0.5]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)
::

code::
(
ImmDef({ |t|

	var pf = PField.spotlightFixed( 0.5, 0.5);
	            //time,  c
	var x = pf .( t,     { |x| (sin(x*5)+1)/2 }.lift.(t) );

	PGridPlot( x, "spotlightFixed")

}, surface: PPlane(RealVector3D[-1.0,-1.0,1.0], RealVector3D[2.0,0.0,0.0], RealVector3D[0.0,2.0,0.0] ), delta: 0.1).test( startTime:0.0)
)
::



METHOD:: expandContract
A PField that "grows" symetrically from a start point (u2,v2) until occupying the entire surface and then shrinks into the antipodal point.

The PField has arguments t, u2, v2, c (0-1), curve where (u2,v2) is the start point, c is the grow factor.

note::Only valid for spherical surfaces.::


returns:: PField

discussion::
code::
(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, u0, v0, c, curve|

	var pf1 = PField.expandContract.plot( t,  u0, v0, c, curve);

	PGridPlot( pf1);

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1, [\u0, [0, 2pi], \v0, ControlSpec(pi/2.neg,pi/2, default:0), \c, nil, \curve, ControlSpec(-6,6,default:0) ]);

q.mod = ImmMod(q.def);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui;
)

::

METHOD:: barU
A PField that grows parallel to the u axis.

The PField has arguments t, wideness (0-1).

returns:: PField

discussion::

code::
(
ImmDef({ |t|

	var pf = PField.barU;
	                      //wideness
	pf.plot( t,  t.lfsine(0.5) );

}, delta: 0.1).test( startTime:0.0)
)

(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, wideness|

	var pf1 = PField.barU.plot( t, wideness );

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1,[
	\wideness, [0.0 ,1.0]
]);

q.mod = ImmMod(q.def, [\wideness, 0.0]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)
::

METHOD:: barV
A PField that grows parallel to the v axis.

The PField has arguments t, wideness (0-1).

returns:: PField

discussion::

code::
(
ImmDef({ |t|

	var pf = PField.barV;
	                      //wideness
	pf.plot( t,  t.lfsine(0.5) );

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)

(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, wideness|

	var pf1 = PField.barV.plot( t, wideness );

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1,[
	\wideness, [0,1.0]
]);

q.mod = ImmMod(q.def, [\c, 0.5]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)
::

code::
(
ImmDef({ |t|

	var pf = PField.barV;
	           //t,  wideness
	var x = pf.( t,  t.lfsine(0.5) );

	PGridPlot(x, "hello !")

}, surface: PPlane(RealVector3D[-1.0,-1.0,1.0], RealVector3D[2.0,0.0,0.0], RealVector3D[0.0,2.0,0.0] ), delta: 0.1).test( startTime:0.0)
)

::

METHOD:: sphericalHarmonic

A PField which uses the spherical harmonic functions for given m,n coeficients. The spherical harmonic function is multiplied with a monocromatic source at frequency f.

The PField has arguments t, f where f is the frequency of the monocromatic source.

ARGUMENT:: m
Integer - range: -l <= m <= l

ARGUMENT:: l
Integer - range 0,1,...

returns:: PField

discussion::

code::
(

ImmDef({ |t|

	//var pf = PField.sphericalHarmonic(0,0);
	var pf = PField.sphericalHarmonic(1,2);
	//var pf = PField.sphericalHarmonic(2,1);
	           //    t, f
	pf.plot( t, 3.0 );

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)

(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, f|
                                          //  -l <= m <= l
	var pf1 = PField.sphericalHarmonic(2,2).plot( t, f );

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1,[
	\freq, [1/10, 4]
]);

q.mod = ImmMod(q.def, [\freq, 2]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)


//plane
(
ImmDef({ |t|

	//var pf = PField.sphericalHarmonic(0,0);
	var pf = PField.sphericalHarmonic(1,2);
	//var pf = PField.sphericalHarmonic(2,1);

	var x = PField({ |u,v,t| pf.func.(u*2*pi,v*pi,t) }).( t, 3.0 );
	PGridPlot( x, "hello !")


}, surface: PPlane(RealVector3D[-1.0,-1.0,1.0], RealVector3D[2.0,0.0,0.0], RealVector3D[0.0,2.0,0.0] ), delta: 0.1).test( startTime:0.0)
)

::


subsection:: reactive pfields and pre-evaluated pfields

Pre-evaluted pfields return an FPSignal instead of a PField.

Reactive fields are not straight mathematical functions, they use switching (FRP) to change the mathematical function being used when some event comes in. This allows to essentially generate new mathematical functions at runtime while the PField is running. Another reason for a PField to be pre-evaluated is to be able to "slowdown" time in order to be able to smoothly change the frequency of a periodic pfield.

METHOD:: wave2D

A PField which implements a wave travelling throught the surface caused by a point source at (u0,v0) with signal given by function g  where the speed of propagation is proportional to l. The speed of propagations controls the spatial wavelenght, i.e. how far apart in space two peaks of the signal are.

ARGUMENT:: t
FPSignal

ARGUMENT:: u0
SimpleNumber or FPSignal[ SimpleNumber ]
In range surface.manifold.rangeU

ARGUMENT:: v0
SimpleNumber or FPSignal[ SimpleNumber ]
In range surface.manifold.rangeV

ARGUMENT:: l
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: freq
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: g
Function

ARGUMENT:: plot
Boolean - If true plot pfield with PSmoothPlot

returns:: FPSignal[ [Float] ]

discussion::

note::
In order for freq to be the frequency in Hertz the function should have period of 1.
l controls the spatial frequency/wavelenght.
This method returns an FPSignal and not a PField.
::

code::
(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, u0, v0, l, freq|

	//make our own non linear shape to go from a to b
	var x = Env([ 0.0, 1.0, 0.5, 1.0, 0.0 ], [ 0.25, 0.25, 0.25, 0.25 ], [ -2.2, 2.1, 1.8, -2 ]).asMultichannelArray[0];

	var g = { |t| x.envAt(t.mod(1.0)) };

	var pf1 = PField.wave2D(t, u0, v0, l, freq, g, true);

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1, [\u0, [0,2pi], \v0, [-pi,pi], \l, [0.0, 2.0], \freq, [1/10,2] ]);

q.mod = ImmMod(q.def, [\l, 0.4, \freq, 1]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)
::

METHOD:: wave2DSin

A PField which implements a wave travelling throught the surface caused by a point source at (u0,v0) with signal given by sinusoidal function  where the speed of propagation is proportional to l.

ARGUMENT:: t
FPSignal

ARGUMENT:: u0
SimpleNumber or FPSignal[ SimpleNumber ]
In range surface.manifold.rangeU

ARGUMENT:: v0
SimpleNumber or FPSignal[ SimpleNumber ]
In range surface.manifold.rangeV

ARGUMENT:: l
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: freq
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: plot
Boolean - If true plot pfield with PSmoothPlot

returns:: FPSignal[ [Float] ]

discussion::

note::
l controls the spatial frequency/wavelenght.
This method returns an FPSignal and not a PField.
::

code::
(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, u0, v0, l, freq|

	var pf1 = PField.wave2DSin(t, u0, v0, l, freq, true);

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1, [\u0, [0,2pi], \v0, [-pi,pi], \l, [0.0, 2.0], \freq, [1/10,2] ]);

q.mod = ImmMod(q.def, [\l, 0.4, \freq, 1]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)
::

METHOD:: wave2DSaw

A PField which implements a wave travelling throught the surface caused by a point source at (u0,v0) with signal given by a saw like function where the speed of propagation is proportional to l.

ARGUMENT:: t
FPSignal[ Float ]

ARGUMENT:: u0
SimpleNumber or FPSignal[ SimpleNumber ]
In range surface.manifold.rangeU

ARGUMENT:: v0
SimpleNumber or FPSignal[ SimpleNumber ]
In range surface.manifold.rangeV

ARGUMENT:: l
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: freq
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: plot
Boolean - If true plot pfield with PSmoothPlot

returns:: FPSignal[ [Float] ]

discussion::

note::
In order for freq to be the frequency in Hertz the function should have period of 1.
l controls the spatial frequency/wavelenght.
This method returns an FPSignal and not a PField.
::

code::
//PField.wave2DSaw
(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, u0, v0, l, freq|

	var pf1 = PField.wave2DSaw(t, u0, v0, l, freq, true);

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1, [\u0, [0,2pi], \v0, [-pi,pi], \l, [0.0, 2.0], \freq, [1/10,2] ]);

q.mod = ImmMod(q.def, [\l, 0.4, \freq, 1]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui
)
::

METHOD:: continousRandomSpotlight
A PField that grows symetrically from a start point until occupying all the surface and then shrinks back to the same point, it then randomly chooses another point to grow to and repeats the process. It takes numSecs to grow and shrink back to the chosen point.

ARGUMENT:: t
FPSignal[ Float ]

ARGUMENT:: numSecs
SimpleNumber or FPSignal[ SimpleNumber ]


ARGUMENT:: curve
SimpleNumber or FPSignal[ SimpleNumber ]


returns::  FPSignal[ [Float] ]

discussion::

code::
(
ImmDef({ |t|
	//surface, t, numSecs
	var x = PField.continousRandomSpotlight( t, 5);

	PGridPlot( x * 2 )

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)

(
q = ();
q.m = 20;
q.surface = PSphere(q.m);

q.def = ImmDef({ |t, numSecs, curve|

	var pf1 = PField.continousRandomSpotlight(t, numSecs, curve);

	PGridPlot( pf1);

	( amp: USpecArg( pf1 ) )

}, q.surface, 0.1, [\numSecs, [0.5,10], \curve, ControlSpec(-6,6,default:0) ]);

q.mod = ImmMod(q.def, [\numSecs, 2]);

q.u = [\immWhiteNoise, [\amp: 0.23, \ampLag, 0.1], q.mod];

q.chain = ImmUChain(q.surface, 0, 1, inf, true, q.u).fadeIn_(1).fadeOut_(1);

q.score = ImmUScore(q.surface, q.chain);
q.score.prepareAndStart;
q.chain.gui;
)
::

METHOD:: continousRandomSpotlight2
A PField that grows symetrically from a start point until occupying all the surface and then shrinks back to the same point, it then randomly chooses another point to grow to and repeats the process. It takes numSecs to grow and shrink back to the chosen point.

numSecs is calculated randomly between numSecsLo and numSecsHi

ARGUMENT:: t
FPSignal

ARGUMENT:: numSecsLo
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: numSecsHi
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: curve
SimpleNumber or FPSignal[ SimpleNumber ]

returns:: FPSignal[ [Float] ]

discussion::

code::
(
ImmDef({ |t|
	//surface, t, numSecs
	var x = PField.continousRandomSpotlight( t, 5);

	PGridPlot( x * 2 )

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)

(
q = ();
q.m = 40;
q.surface = PSphere(q.m);

q[\f] = { |t|

	//surface, t, numSecs
	var x = PField.continousRandomSpotlight( t, 5);

	PGridPlot( x * 2 );


	(freq: UArg( x.linexp(0.0,1.0,100,10000) ))
};

q.chain = ImmUChain(q.surface, \immWhiteNoise, [\lowPass, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);
q.score = ImmUScore(q.surface, q.chain);
q.score.gui;
q.score.prepareAndStart
)
::



METHOD:: randomHills
Every num seconds switches into a new function. Each function is composed of the sum of code::numHills:: spotlight functions with centers on random points (the hills) each hill having a random wideness given  in [sizeA, sizeB] and height in [heightA, heightB]. The animation progressivelly crossfades from one set of hills to another every code::numSeconds:: seconds.

ARGUMENT:: t
FPSignal[ Float ]

ARGUMENT:: numSecs
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: numHills
Integer or FPSignal[ Integer ]

ARGUMENT:: sizeA
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

ARGUMENT:: sizeB
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

ARGUMENT:: bumpSize
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

ARGUMENT:: heightA
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

ARGUMENT:: heightB
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

returns::  FPSignal[ [Float] ]

discussion::

When using an FPSignal for numSecs, the number of seconds is only sampled when switching occurs to the new set of hills. So if the previous numSecs value was 8seconds, even if the numSecs signal changes in the mean time, only after 8 seconds will the new value of numSecs signal be sampled.

code::
(

ImmDef({ |t|
	//surface, t, numSecs, numHills = 5
	var x = PField.randomHills( t, 5, 5);

	PHemiPlot( x * 2 )

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)
(
q = ();
q.m = 40;
q.surface = PSphere(q.m);

q[\f] = { |t|

	var x = PField.randomHills( t, 5, 5);

	PHemiPlot( x * 2 );

	(freq: UArg( x.linexp(0.0,1.0,100,10000) ))
};

q.chain = ImmUChain(q.surface, \immWhiteNoise, [\lowPass, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);
q.score = ImmUScore(q.surface, q.chain);
q.score.gui;
q.score.prepareAndStart
)
::

METHOD:: randomHills2
Every num seconds switches into a new function, where num is ramdomly choosen between numSecsLo and numSecsHi. Each function is composed of the sum of code::numHills:: spotlight functions with centers on random points (the hills) each hill having a random wideness given  in [sizeA, sizeB] and height in [heightA, heightB]. The animation progressivelly crossfades from one set of hills to another every code::numSeconds:: seconds.

ARGUMENT:: t
FPSignal[ Float ]

ARGUMENT:: numSecsLo
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: numSecsHi
SimpleNumber or FPSignal[ SimpleNumber ]

ARGUMENT:: numHills
Integer or FPSignal[ Integer ]

ARGUMENT:: sizeA
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

ARGUMENT:: sizeB
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

ARGUMENT:: bumpSize
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

ARGUMENT:: heightA
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

ARGUMENT:: heightB
SimpleNumber or FPSignal[ SimpleNumber ] - range [0,1]

returns::  FPSignal[ [Float] ]

discussion::

When using an FPSignal for numSecs, the number of seconds is only sampled when switching occurs to the new set of hills. So if the previous numSecs value was 8seconds, even if the numSecs signal changes in the mean time, only after 8 seconds will the new value of numSecs signal be sampled.

code::
(
ImmDef({ |t|
	//surface, t, numSecs, numHills = 5
	var x = PField.randomHills( t, 5, 5);

	PGridPlot( x * 2 );
	PHemiPlot( x * 2 )

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)
(
q = ();
q.m = 40;
q.surface = PSphere(q.m);

q[\f] = { |t|

	var x = PField.randomHills( t, 5, 5);

	PHemiPlot( x * 2 );

	(freq: UArg( x.linexp(0.0,1.0,100,10000) ))
};

q.chain = ImmUChain(q.surface, \immWhiteNoise, [\lowPass, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);
q.score = ImmUScore(q.surface, q.chain);
q.score.gui;
q.score.prepareAndStart
)
::




METHOD:: randomHillsBipolar
every num seconds switches into a new function. Each function is composed of the sum of code::numHills:: spotlight functions with centers on random points (the hills). Some hills have a positive number associated (contribute upwards) and others have a negative number (contribute downwards). The animation progressivelly crossfades from one set of hills to another every code::numSeconds:: seconds.


ARGUMENT:: t
FPSignal[ Float ]

ARGUMENT:: numSecs
SimpleNumber

ARGUMENT:: numHills
Integer

ARGUMENT:: sizeA
Float (0-1)

ARGUMENT:: sizeB
Float (0-1)

ARGUMENT:: bumpSize
Float (0-1)

returns::  FPSignal[ [Float] ]

discussion::

code::
(
ImmDef({ |t|
	var x = PField.randomHillsBipolar( t, 5, 2);

	PHemiPlot( x )

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)

(
q = ();
q.m = 40;
q.surface = PSphere(q.m);

q[\f] = { |t|

	var x = PField.randomHillsBipolar( t, 5, 2);

	PHemiPlot( x * 2 );

	(freq: UArg( x.linexp(0.0,1.0,100,10000) ))
};

q.chain = ImmUChain(q.surface, \immWhiteNoise, [\lowPass, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);
q.score = ImmUScore(q.surface, q.chain);
q.score.gui;
q.score.prepareAndStart
)
::


METHOD:: moveHills

code::numHills:: spotlight functions are created with random center locations and wideness given by code::size::. On each iteration of the timer (the time between iteration is given by the delta parameter of ImmDef) the center of each hill is moved in a random direction by a distance given by code::step::. The parameters are not yet modulateable.


ARGUMENT:: t
FPSignal

ARGUMENT:: numSecs
SimpleNumber

ARGUMENT:: numHills
SimpleNumber

ARGUMENT:: size
SimpleNumber

ARGUMENT:: step
SimpleNumber

ARGUMENT:: startInSamePlace
Boolean
If true all spotlights start at the same location.

returns::  FPSignal[ [Float] ]

discussion::

code::
(
q = ();
q.m = 40;
q.surface = PSphere(q.m);

q[\f] = { |t|

	var x = PField.moveHills(t:t, numSecs:0.5, numHills:5, size:0.35, step:1, startInSamePlace:false);

	PGridPlot( x );

    (freq: UArg( x.linexp(0.0,1.0,100,10000) ))
};

q.chain = ImmUChain(q.surface, \immWhiteNoise, [\lowPass, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);
q.score = ImmUScore(q.surface, q.chain);
q.score.gui;
q.score.prepareAndStart
)
::




INSTANCEMETHODS::

PRIVATE:: composeNAryOp, reverseComposeBinaryOp, <>, valueArray, composeBinaryOp, composeUnaryOp, plotImage, valueArrayS, valuePlot, valueS, animate


METHOD:: func
The actual mathematical function of the PField
returns:: Function

METHOD:: value
Evaluate the PField

ARGUMENT::  ... args
Of kind FPSignal[ SimpleNumber ] or SimpleNumber

returns::  FPSignal[ [Float] ]

METHOD:: rotate

Create a new PField which allows for rotation around 3 axis.

The new PField has 3 extra arguments prepended to the argument list for the 3 angles of rotation (rotate, tilt, tumble).

note::Only valid for spherical surfaces.::

discussion::
code::
(
ImmDef({ |t|

	var pf = PField.spotlightFixed(0,0).rotate;
                  // t,     rotate  tilt     tumble   c
	pf.plot( t,  0.0,    0.0,     t,       0.5 );

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)
)
::

Examples::

It's possible to switch from a pfield to another after a certain ammount of seconds:

code::
//later
(

ImmDef({ |t|

	var pf1 = PField({ |u, v, t|
		sin(u + t)
	});
	var x = pf1.(t);
	var pf2 = PField({ |u, v, t|
		1.0
	});
	var y = pf2.(t);
	PGridPlot( x.switchLater(t, y, 4), "switchLater")

}, surface: PGeodesicSphere(), delta: 0.1).test( startTime:0.0)

)
::

If one wants to change values of the pfield arguments or other elements of the signal by typing code one can use VarProxy:

code::

(
q = ();
q.m = 40;
q.surface = PSphere(q.m);

q[\f] = { |t|
	var pf = PField.spotlight;

	var c = VarProxy.enIn(\x, 0.5);
	var d = c.enDebug("c");
	               //t, u,     v,    c,    d
	var out = PSmoothPlot( pf, t, 0.0,   0.0,  c,  0.0 );

	(freq: UArg( out.linexp(0.0,1.0,100,10000) ))
};

q.chain = ImmUChain(q.surface, \immWhiteNoise, [\lowPass, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);
q.score = ImmUScore(q.surface, q.chain);
q.score.gui;
q.score.prepareAndStart
)


VarProxy(\x, 0.0)
VarProxy(\x, 1.0)

//when we don't need this score anymore (i.e. before evaluating the block of code above again) we should dispose of the score in order to stop disconnect everything in the event network:
q.score.stop
q.score.disconnect
::

Closing windows automatically with cmd-.

code::
(
q = ();
q.m = 40;
q.surface = PSphere(q.m);

q[\f] = { |t|

	var x = PField.moveHills(t:t, numSecs:0.5, numHills:5, size:0.35, step:1, startInSamePlace:false);

	PGridPlot( x );

    (freq: UArg( x.linexp(0.0,1.0,100,10000) ))
};

q.chain = ImmUChain(q.surface, \immWhiteNoise, [\lowPass, nil , ImmDef(q[\f], q.surface, 0.1) ] ).fadeIn_(1).fadeOut_(1);
q.score = ImmUScore(q.surface, q.chain);
q.scoregui = q.score.gui;
q.score.prepareAndStart;
CmdPeriod.add({q.scoregui.close; });
)
::





